<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>ProxySG Auto Sysinfo Report</title>
<style>
  body { font-family: "Segoe UI", Arial, sans-serif; background: #f5f7fa; margin: 20px; color:#333; }
  h1 {
    background: #1e3a5f; 
    color: white; 
    padding: 12px 18px; 
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    align-items: flex-end;  /* 아래 정렬 */
    margin-bottom: 5pt;  /* 여백 5pt */
  }
  .date-header {
    font-size: 16px;
    color: #fff;
    margin: 0;
  }
  .section { background: white; margin: 20px 0; border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); }
  .section-header { background: #1e3a5f; color: white; padding: 6px 12px; border-radius: 8px 8px 0 0; font-weight: bold; }
  table { width: 100%; border-collapse: collapse; }
  th, td { border: 1px solid #ccc; padding: 6px 10px; text-align: center; font-size: 13px; }
  th { background: #f0f2f5; font-weight: bold; }
  .nok { background-color: #f9d6d6; }  /* 빨간색 배경 */
  .yellow { background-color: #fff3cd; }  /* 노란색 */
  .red { background-color: #f8d7da; }     /* 빨간색 */
  .white { background-color: #f0f2f5; }     /* 기본 흰색 */
  input[type=file] { margin: 15px 0; }
  button { background:#1e3a5f; color:white; border:none; padding:8px 16px; border-radius:6px; cursor:pointer; margin-top:10px; }
  button:hover { background:#294b7a; }
</style>
</head>
<body>

<h1>ProxySG Auto Sysinfo Report
<!-- 날짜를 오른쪽에 표시 -->
  <div class="date-header" id="today-date"></div></h1>

<input type="file" id="fileInput" accept=".txt">
<div id="report"></div>

<script>
    // 오늘 날짜 구하기 (yyyy. mm. dd. 형식)
    function formatDate(date) {
      const year = date.getFullYear();
      const month = (date.getMonth() + 1).toString().padStart(2, '0'); // 월은 0부터 시작하므로 +1
      const day = date.getDate().toString().padStart(2, '0'); // 날짜 두 자릿수로 맞추기
      return `${year}. ${month}. ${day}.`;
    }

    const today = new Date();
    const formattedDate = formatDate(today);

	//  날짜 차이 배경 계산기
	function getDateClass(dateString) {
      const today = new Date();
      const targetDate = new Date(dateString);

      // 날짜 차이 계산 (밀리초 단위)
      const timeDiff = today - targetDate;

      // 날짜 차이를 일(day) 단위로 변환
      const diffInDays = Number(Math.floor(timeDiff / (1000 * 3600 * 24)));
      
      // 날짜 차이에 따라 클래스를 적용
      if (diffInDays < 0) {
        return "red";  // 마이너스 값은 무조건 빨간색
      } else if (diffInDays <= 30) {
        return "red";  // 30 이하 값은 빨간색
      } else if (diffInDays <= 60) {
        return "yellow"; // 60 이하 값은 노란색
      } else {
        return "white"; // 60보다 큰 값은 흰색
      }
    }
    
    //  날짜 차이 일수 계산기
	function getDateDiff(dateString) {
      const today = new Date();
      const date = new Date(dateString);

      // 날짜 차이 계산 (밀리초 단위)
      const timeDiff = today - date;

      // 날짜 차이를 일(day) 단위로 변환
      const diffInDays = Number(Math.floor(timeDiff / (1000 * 3600 * 24)));
      
      return diffInDays
      
    }



// 날짜를 페이지에 표시
document.getElementById("today-date").innerHTML = `오늘 날짜: ${formattedDate}`;

document.getElementById("fileInput").addEventListener("change", function(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = function(ev) {
    const text = ev.target.result;
    const match = (r) => text.match(r)?.[1]?.trim() || "-";
    const oknok = (v) => (v.match(/NOK/i) ? 'class="nok"' : "");

    // -----------------------------
    // ✅ General Info
    // -----------------------------
    const host = match(/appliance-name\s+"([\w\-]+)"/i);
    const model = match(/Model\s*:\s*([A-Za-z0-9\-]+)/i);
    const serial = match(/Serial\s*Number\s*:\s*([0-9A-Z]+)/i);

    // SGOS Version (엑셀 SUBSTITUTE + VLOOKUP 로직 기반)
    let sgos = "-";
    const versionLine = text.match(/Version:\s*([^\n]+)/i);
    if (versionLine) sgos = versionLine[1].replace(/"/g, "").trim();

    // ✅ HW/SW Uptime (엑셀 MID + SUBSTITUTE + IF)
    let uptimeHW = "-";
    let uptimeSW = "-";
    let uptime = "-";

    // Match "hardware rebooted 891 days 15 hours ago"
    const hwMatch = text.match(/hardware rebooted\s+(\d+\s+days\,\s+\d+\s+hours)/i);
    if (hwMatch) uptimeHW = hwMatch[1].trim();

    // Match "software rebooted 891 days 15 hours ago"
    const swMatch = text.match(/softdware rebooted\s+(\d+\s+days\,\s+\d+\s+hours)/i);
    if (swMatch) uptimeSW = swMatch[1].trim();

    // Combine SW / HW values
    if (uptimeHW !== "-" && uptimeSW !== "-") {
      uptime = uptimeHW === uptimeSW ? uptimeHW : `${uptimeSW} / ${uptimeHW}`;
    } else {
      uptime = uptimeHW !== "-" ? uptimeHW : uptimeSW;
    }

    const cpuTemp = match(/CPU\s*\d*\s*temperature\s*([0-9]+(?:\.[0-9]+)?)\s*degrees\s/i);
    const sysTemp = match(/System center temperature\s*([0-9]+(?:\.[0-9]+)?)\s*degrees\s/i);
    
    // Explicit과 External 트래픽 비교
function sumBytesByKeys(keys) {
  let sum = 0;
  for (const key of keys) {
    const match = text.match(new RegExp(`${key}[^\n]*:\\s*([0-9\\s]+)`, "i"));
    if (match) {
      const nums = match[1].trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
      if (nums.length > 0) sum += nums.reduce((a, b) => a + b, 0);
    }
  }
  return sum;
}

// Explicit과 External의 키워드
const explicitKeys = [
  "svc:service:HTTP:Explicit HTTP:intercepted_client_bytes~monthly"
];
const externalKeys = [
  "svc:service:HTTP:External HTTP:intercepted_client_bytes~monthly"
];

// 합계 계산
const explicitBytes = sumBytesByKeys(explicitKeys);
const externalBytes = sumBytesByKeys(externalKeys);

// 더 큰 값을 가진 항목을 표기
const deploymentMode = explicitBytes > externalBytes ? "Explicit" : "TP";


    // -----------------------------
    // Hardware & Network
    // -----------------------------
    // ✅ CPU Usage (Now)
    let cpuNow = "-";
    const cpuHourlyMatch = text.match(/system:cpu-usage~hourly[^\n]*:\s*([0-9\s]+)/i);
    if (cpuHourlyMatch) {
      const nums_cpu = cpuHourlyMatch[1].trim().split(/\s+/).map(Number);
      cpuNow = nums_cpu.at(-1) + "%"; // 마지막 값
    }

    // ✅ CPU Peak
    let cpuPeak = "-";
    const cpuDailyMatch = text.match(/system:cpu-usage~daily[^\n]*:\s*([0-9\s]+)/i);
    if (cpuHourlyMatch || cpuDailyMatch) {
      const hourlyMax_cpu = cpuHourlyMatch ? Math.max(...cpuHourlyMatch[1].trim().split(/\s+/).map(Number)) : 0;
      const dailyMax_cpu = cpuDailyMatch ? Math.max(...cpuDailyMatch[1].trim().split(/\s+/).map(Number)) : 0;
      const peak_cpu = Math.max(hourlyMax_cpu, dailyMax_cpu);
      cpuPeak = peak_cpu + "%";
    }
    
    
    
    // ✅ MEM Usage (Now)
    let memNow = "-";
    const memHourlyMatch = text.match(/system:memory-usage~hourly[^\n]*:\s*([0-9\s]+)/i);
    if (memHourlyMatch) {
      const nums_mem = memHourlyMatch[1].trim().split(/\s+/).map(Number);
      memNow = nums_mem.at(-1) + "%"; // 마지막 값
    }

    // ✅ MEM Peak
    let memPeak = "-";
    const memDailyMatch = text.match(/system:memory-usage~daily[^\n]*:\s*([0-9\s]+)/i);
    if (memHourlyMatch || memDailyMatch) {
      const hourlyMax_mem = memHourlyMatch ? Math.max(...memHourlyMatch[1].trim().split(/\s+/).map(Number)) : 0;
      const dailyMax_mem = memDailyMatch ? Math.max(...memDailyMatch[1].trim().split(/\s+/).map(Number)) : 0;
      const peak_mem = Math.max(hourlyMax_mem, dailyMax_mem);
      memPeak = peak_mem + "%";
    }
    
    // ✅ Disk Status 종합 판단
    let disk = "-";
    const diskBlocks = text.match(/Stat:\s*Disk\s+\d+\s+Status[\s\S]*?(?=Stat:|$)/gi);
    if (diskBlocks && diskBlocks.length > 0) {
      const allOK = diskBlocks.every(block => /Current\s+State\s*:\s*OK/i.test(block));
      disk = allOK ? "OK" : "NOK";
    }




    // ✅ Tx / Rx Rate 계산
    let txRate = "-";
    let rxRate = "-";

    const interfaces = [];
    for (let i = 0; i <= 4; i++) {
      for (let j = 0; j <= 3; j++) {
        interfaces.push(`${i}:${j}`);
      }
    }

    // 공통 처리 함수
    function calcRate(direction) {
      let maxAvg = 0;
      for (const iface of interfaces) {
        const key = `tcpip:interface:${iface}:bytes-${direction}~daily15minute`;
        const match = text.match(new RegExp(`${key}[^\n]*:\\s*([\\d\\s]+)`, "i"));
        if (match) {
          const nums = match[1].trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
          if (nums.length > 0) {
            // 상위 32개 평균
            const top32 = nums.sort((a, b) => b - a).slice(0, 32);
            const avg = top32.reduce((a, b) => a + b, 0) / top32.length;

            // byte → bit 변환, 900초(15분) 기준 환산
            const bps = (avg * 8) / 900;
            const mbps = bps / 1_000_000;
            if (mbps > maxAvg) maxAvg = mbps;
          }
        }
      }

      // 단위 결정
      if (maxAvg > 0) {
        return maxAvg >= 1 ? `${maxAvg.toFixed(1)} Mbps` : `${(maxAvg * 1000).toFixed(1)} Kbps`;
      }
      return "-";
    }

    // Tx / Rx 모두 계산
    txRate = calcRate("sent");
    rxRate = calcRate("received");

    
    
    // ✅ Users (엑셀의 @getmax 로직 기반)
    let users = "-";

    const usersMatch = text.match(/users:current~monthly[^\n]*:\s*([0-9\s]+)/i);
    if (usersMatch) {
      const nums = usersMatch[1].trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
      if (nums.length > 0) {
        const maxUsers = Math.max(...nums);
        users = maxUsers.toString();
      }
    }


    // ✅ HTTPS Sessions (엑셀의 @getmax 로직 기반)
    let httpsSessions = "-";

    const sessionMatch = text.match(/http:client-volume~monthly[^\n]*:\s*([0-9\s]+)/i);
    if (sessionMatch) {
      const nums = sessionMatch[1].trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
      if (nums.length > 0) {
        const maxSess = Math.max(...nums);
        httpsSessions = maxSess.toString();
      }
    }

    

    //-------------------------------------------------------------
    // ✅ ① Total Traffic (svc:ds:proxy:intercepted_client_bytes~monthly)
    //-------------------------------------------------------------
    let totalTraffic = "-";

    const totalMatch = text.match(/svc:ds:proxy:intercepted_client_bytes~monthly[^\n]*:\s*([0-9\s]+)/i);
    if (totalMatch) {
      const nums = totalMatch[1].trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
      if (nums.length > 0) {
        const sumBytes = nums.reduce((a, b) => a + b, 0);

        // Byte → MB/GB/TB 단위 변환 (10진 단위)
        let value = sumBytes;
        let unit = "Bytes";
        if (value >= 1e12) {
          value = value / 1e12;
          unit = "TB";
        } else if (value >= 1e9) {
          value = value / 1e9;
          unit = "GB";
        } else if (value >= 1e6) {
          value = value / 1e6;
          unit = "MB";
        } else if (value >= 1e3) {
          value = value / 1e3;
          unit = "KB";
        }
        totalTraffic = `${value.toFixed(2)} ${unit}`;
      }
    }

    //-------------------------------------------------------------
    // ✅ Peak Traffic (monthly/daily/hourly 단위별 변환 포함)
    //-------------------------------------------------------------
    let peakTraffic = "-";
    let peakMbps = 0;

    // 대상 키워드와 단위 변환 비율 (초 단위로 나누는 값)
    const peakKeys = [
      { key: "svc:ds:proxy:intercepted_client_bytes~monthly", divisor: 24 * 60 * 60 },
      { key: "svc:ds:proxy:intercepted_client_bytes~daily", divisor: 60 * 60 },
      { key: "svc:ds:proxy:intercepted_client_bytes~hourly", divisor: 60 }
    ];

    // 각 구간별로 최대값 비교
    for (const item of peakKeys) {
      const match = text.match(new RegExp(`${item.key}[^\n]*:\\s*([0-9\\s]+)`, "i"));
      if (match) {
        const nums = match[1].trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
        if (nums.length > 0) {
          const maxBytes = Math.max(...nums);

          // Byte → bit 변환 후, 해당 구간 시간 단위로 나누고 Mbps로 변환
          const bps = (maxBytes * 8) / item.divisor;
          const mbps = bps / 1_000_000;

          if (mbps > peakMbps) peakMbps = mbps;
        }
      }
    }

    if (peakMbps > 0) {
      peakTraffic = `${peakMbps.toFixed(1)} Mbps`;
    }


    //-------------------------------------------------------------
    // ✅ HTTP% + HTTPS% 계산 (엑셀 Sysinfo_1 동일)
    //-------------------------------------------------------------

    // 안전한 키워드 매칭 함수 (공백/특수문자 대응)
    function safeMatchKey(key) {
      const safeKey = key.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      return text.match(new RegExp(`${safeKey}[^\n]*:\\s*([0-9\\s]+)`, "i"));
    }

    // 특정 키워드 세트의 숫자 합계 계산 함수
    function sumBytesByKeys(keys) {
      let sum = 0;
      for (const key of keys) {
        const match = safeMatchKey(key);
        if (match) {
          const nums = match[1].trim().split(/\s+/).map(Number).filter(n => !isNaN(n));
          if (nums.length > 0) sum += nums.reduce((a, b) => a + b, 0);
        }
      }
      return sum;
    }

    //------------------------
    // ✅ HTTP% 계산
    //------------------------
    let httpPercent = "-";

    const httpKeys = [
      "svc:proxy:HTTP:intercepted_client_bytes~monthly",
      "svc:proxy:HTTP:bypassed_bytes~monthly"
    ];
    const totalKeys_HTTP = [
      "svc:ds:proxy:bypassed_bytes~monthly",
      "svc:ds:proxy:intercepted_client_bytes~monthly"
    ];

    const httpBytes = sumBytesByKeys(httpKeys);
    const totalBytes_HTTP = sumBytesByKeys(totalKeys_HTTP);

    if (httpBytes > 0 && totalBytes_HTTP > 0) {
      const ratio = (httpBytes / totalBytes_HTTP) * 100;
      httpPercent = `${ratio.toFixed(1)}%`;
    }

    //------------------------
    // ✅ HTTPS% 계산
    //------------------------
    let httpsPercent = "-";

    const httpsKeys = [
      "svc:proxy:HTTPS Forward Proxy:intercepted_client_bytes~monthly"
    ];
    const sslKeys = [
      "svc:proxy:SSL:intercepted_client_bytes~monthly",
      "svc:proxy:SSL:bypassed_bytes~monthly"
    ];
    const totalKeys_HTTPS = [
      "svc:ds:proxy:bypassed_bytes~monthly",
      "svc:ds:proxy:intercepted_client_bytes~monthly"
    ];

    const httpsBytes = sumBytesByKeys(httpsKeys);
    const sslBytes = sumBytesByKeys(sslKeys);
    const totalBytes_HTTPS = sumBytesByKeys(totalKeys_HTTPS);

    if (totalBytes_HTTPS > 0 && (httpsBytes > 0 || sslBytes > 0)) {
      const httpsRatio = httpsBytes / totalBytes_HTTPS;
      const sslRatio = sslBytes / totalBytes_HTTPS;
      const totalRatio = (httpsRatio + sslRatio) * 100;
      httpsPercent = `${totalRatio.toFixed(1)}%`;
    }

    //-------------------------------------------------------------
    // ✅ Savings% 계산 (엑셀 Sysinfo_1 동일)
    //-------------------------------------------------------------
    let savingsPercent = "-";

    // 키워드 정의
    const serverKeys = ["svc:ds:proxy:intercepted_server_bytes~monthly"];
    const clientKeys = ["svc:ds:proxy:intercepted_client_bytes~monthly"];

    // 서버 / 클라이언트 바이트 합계 계산
    const serverBytes = sumBytesByKeys(serverKeys);
    const clientBytes = sumBytesByKeys(clientKeys);

    // 절감율 계산
    if (serverBytes > 0 && clientBytes > 0) {
      const ratio = (1-(serverBytes / clientBytes)) * 100;
      savingsPercent = `${ratio.toFixed(1)}%`;
    }


    // -----------------------------
    // Proxy Features
    // -----------------------------
    // 날짜 포맷을 'yyyy. mm. dd.' 형식으로 변환하는 함수
    function formatDate(dateString) {
      const date = new Date(dateString);
      const year = date.getFullYear();
      const month = (date.getMonth() + 1).toString().padStart(2, '0'); // 월은 0부터 시작하므로 +1
      const day = date.getDate().toString().padStart(2, '0'); // 날짜 두 자릿수로 맞추기

      return `${year}. ${month}. ${day}.`;
    }

    // 'Licensed Until:' 키워드에서 날짜 추출
    const licenseMatch = text.match(/Licensed Until:[\s\,\w]*\s(\d{1,2}\s\w{3}\s\d{4})\s/i);
    let licenseDate = "-";

    if (licenseMatch) {
      // 날짜 포맷 변환
      licenseDate = formatDate(licenseMatch[1]);
    }


    
    
    // 데이터 검증 함수
    function getClosestDate(text) {
      // 키워드에 해당하는 날짜 추출 패턴
      const datePattern = /\d{1,2}\s\w{3}\s\d{4}/g;

      // 각 키워드에서 날짜를 추출
      const dataValidMatch = text.match(/Data Valid Until:[^\n]*?(\d{1,2}\s\w{3}\s\d{4})/);
      const blueCoatDownloadMatch = text.match(/Blue Coat download at:[^\n]*?(\d{1,2}\s\w{3}\s\d{4})/);
      const differentialUpdateMatch = text.match(/Differential update[^\n]*?(\d{1,2}\s\w{3}\s\d{4})/);
      const timeMatch = text.match(/Time:\s*(\d{1,2}\s\w{3}\s\d{4})/); // Time: 키워드 찾기

      // 날짜들을 모은 배열
      const dates = [];
      if (dataValidMatch) dates.push(new Date(dataValidMatch[1]));
      if (blueCoatDownloadMatch) dates.push(new Date(blueCoatDownloadMatch[1]));
      if (differentialUpdateMatch) dates.push(new Date(differentialUpdateMatch[1]));
      if (timeMatch) dates.push(new Date(timeMatch[1])); // Time: 날짜 추가

      // 날짜들이 존재하면, 가장 최근 날짜를 반환
      let dataValid = "-"; 
      if (dates.length > 0) {
        const maxDate = new Date(Math.max(...dates));
        dataValid = maxDate.toLocaleDateString();
      }

      // URL 필터 값 설정
      const urlFilter = dataValid === timeMatch ? "BCIS" : "BCWF"; 

      return { dataValid, urlFilter }; 
    }

    // 함수 사용
    const { dataValid, urlFilter } = getClosestDate(text);


    // 로컬 데이터베이스 함수
    const localDBMatch = text.match(/Local database download at:\s*(\d{4}\/\d{2}\/\d{2})\s/i);

    let localDBDate = "-";  // 기본값

    if (localDBMatch) {
      // 날짜 문자열을 yyyy. mm. dd. 형식으로 변환
      const rawDate = localDBMatch[1];  // 2025/07/28
      const dateParts = rawDate.split("/");  // ["2025", "07", "28"]
      localDBDate = `${dateParts[0]}. ${dateParts[1]}. ${dateParts[2]}.`;  // "2025. 07. 28."
    }
    
    const webpulse = match(/WebPulse:\s*(Enabled|Disabled)/i);
    const appProtect = match(/Application Protection:\s*(Enabled|Disabled)/i);
    
    
    // application-classification ;mode 키워드가 포함된 줄 찾기
    const appClassKeywordMatch = text.match(/application-classification\s*;\s*mode/i);

    let appClass = "-";

    if (appClassKeywordMatch) {
      // 키워드가 포함된 줄 인덱스 찾기
      const lines = text.split("\n");  // 텍스트를 줄별로 분리
      const appClassIndex = lines.findIndex(line => line.includes("application-classification ;mode"));

      // 바로 다음 줄 확인
      if (appClassIndex !== -1 && lines[appClassIndex + 1]?.trim() === "enable") {
        appClass = "Enabled";  // 그 다음 줄 값이 'enable'이면 Enabled로 설정
      }
    }


	// security windows-domains ;mode 키워드가 포함된 줄 찾기
    const authKeywordMatch = text.match(/security\swindows\-domains\s*;mode/i);

    let auth = "-";

    if (authKeywordMatch) {
      // 키워드가 포함된 줄 인덱스 찾기
      const auth_lines = text.split("\n");  // 텍스트를 줄별로 분리
      const authIndex = auth_lines.findIndex(line => line.includes("security windows-domains ;mode"));

      // 바로 다음 줄 확인
      if (authIndex !== -1 && auth_lines[authIndex + 1]?.trim().includes("hostname")) {
        auth = "Enabled";
      }
    }

    const etap = match(/client\.connection[\.\w\_]+tap\s*\(([\d\:]+)\)/i);


    // -----------------------------
    // Logging & Services
    // -----------------------------
    const icapReq = match(/ICAP REQ:\s*(\d+)/i);
    const icapResp = match(/ICAP RESP:\s*(\d+)/i);
    
    
    // Title: Access Log (main) Statistics 키워드가 포함된 줄 찾기
    const mainKeywordMatch = text.match(/Title\:\sAccess\sLog\s\(main\)\sStatistics/i);
    let httpLog = "-";
    if (mainKeywordMatch) {
      // 키워드가 포함된 줄 인덱스 찾기
      const main_lines = text.split("\n");  // 텍스트를 줄별로 분리
      const mainIndex = main_lines.findIndex(line => line.includes("Title: Access Log (main) Statistics"));

      // AL_STATS_0037 값을 포함한 37번째 줄 확인
      const http_targetLine = main_lines[mainIndex + 37]?.trim();

      // AL_STATS_0037 다음 값을 추출
      const http_match = http_targetLine.match(/AL_STATS_0037\s*(\d+)/);
      if (http_match) {
        httpLog = (http_match[1]/1000/1000).toFixed(1); // AL_STATS_0037 이후 숫자를 httpLog에 저장
      }
    }


	// Title: Access Log (ssl) Statistics 키워드가 포함된 줄 찾기
    const sslKeywordMatch = text.match(/Title\:\sAccess\sLog\s\(ssl\)\sStatistics/i);
    let httpsLog = "-";
    if (sslKeywordMatch) {
      // 키워드가 포함된 줄 인덱스 찾기
      const ssl_lines = text.split("\n");  // 텍스트를 줄별로 분리
      const sslIndex = ssl_lines.findIndex(line => line.includes("Title: Access Log (ssl) Statistics"));

      // AL_STATS_0037 값을 포함한 37번째 줄 확인
      const ssl_targetLine = ssl_lines[sslIndex + 37]?.trim();

      // AL_STATS_0037 다음 값을 추출
      const ssl_match = ssl_targetLine.match(/AL_STATS_0037\s*(\d+)/);
      if (ssl_match) {
        httpsLog = (ssl_match[1]/1000/1000).toFixed(1); // AL_STATS_0037 이후 숫자를 httpsLog에 저장
      }
    }
    
    
    // format-name ssl 키워드가 포함된 줄 찾기
    const LogbackupKeywordMatch = text.match(/format\-name\sssl/i);

    let Logbackup = "-";

    if (LogbackupKeywordMatch) {
      // 키워드가 포함된 줄 인덱스 찾기
      const Logbackup_lines = text.split("\n");  // 텍스트를 줄별로 분리
      const LogbackupIndex = Logbackup_lines.findIndex(line => line.includes("format-name ssl"));

      // 바로 다음 줄 확인
      if (LogbackupIndex !== -1 && Logbackup_lines[LogbackupIndex + 1]?.trim().includes("ftp-client primary")) {
        Logbackup = "FTP";
      }
    }


    // syslog enable 키워드 확인
    let syslogStatus = "-";
    const syslogMatch = text.match(/syslog\s+enable/i);

    if (syslogMatch) {
      syslogStatus = "Syslog";
    }
    
    
    const coreImage = match(/restart\score\-image\s([\w]+)/i);
    
    
    const getClassForDate = (dateString) => {
    const today = new Date();
    const targetDate = new Date(dateString);

    // 날짜 차이 계산
    const diffInTime = today - targetDate;
    const diffInDays = Math.floor(diffInTime / (1000 * 3600 * 24)); // 일 단위로 변환

    // 색상 클래스 결정
    return (diffInDays <= 30) ? "yellow" : (diffInDays > 30 && diffInDays <= 60 ? "yellow" : "red");
  };

    
    
    // -----------------------------
    // HTML 출력
    // -----------------------------
    document.getElementById("report").innerHTML = `
    <div class="section">
      <div class="section-header">① General Information & Configuration Backup</div>
      <table>
        <tr><th>Host Name</th><th>Model</th><th>Serial Number</th><th>SGOS Version</th>
            <th>Uptime (SW / HW)</th><th>CPU Temp</th><th>System Temp</th><th>Deployment Mode</th></tr>
        <tr>
          <td>${host}</td><td>${model}</td><td>${serial}</td><td>${sgos}</td>
          <td>${uptime}</td><td>${cpuTemp ? cpuTemp+"°C" : "-"}</td>
          <td>${sysTemp ? sysTemp+"°C" : "-"}</td><td>${deploymentMode}</td>
        </tr>
      </table>
    </div>

    <div class="section">
      <div class="section-header">② Hardware & Network</div>
      <table>
        <tr><th>CPU Usage</th><th>MEM Usage</th><th>Disk</th><th>Tx Rate</th><th>Rx Rate</th>
            <th>Users</th><th>HTTPS Sessions</th><th>Total Traffic</th><th>Peak Traffic</th><th>HTTP%</th><th>HTTPS%</th><th>Savings</th></tr>
        <tr>
          <td>${cpuNow} / ${cpuPeak}</td><td>${memNow} / ${memPeak}</td><td ${oknok(disk)}>${disk}</td>
          <td>${txRate}</td><td>${rxRate}</td><td>${users}</td><td>${httpsSessions}</td>
          <td>${totalTraffic}</td><td>${peakTraffic}</td><td>${httpPercent}</td><td>${httpsPercent}</td><td>${savingsPercent}</td>
        </tr>
      </table>
    </div>

    <div class="section">
      <div class="section-header">③ Proxy Features</div>
      <table>
        <tr><th>License Expiry</th><th>Web Filtering Database</th><th>Local DB</th><th>WebPulse</th><th>App Protect</th>
            <th>App Class</th><th>Auth</th><th>eTap</th></tr>
        <tr>
          <td id="licenseDate" class="${getClassForDate(licenseDate)}">${licenseDate} / ${getDateDiff(licenseDate)}</td><td id="dataValid" class="${getClassForDate(dataValid)}">${urlFilter} / ${dataValid} / ${getDateDiff(dataValid)}</td>
          <td id="localDBDate" class="${getClassForDate(localDBDate)}">${localDBDate} / ${getDateDiff(localDBDate)}</td><td>${webpulse}</td><td>${appProtect}</td>
          <td>${appClass}</td><td>${auth}</td><td>${etap}</td>
        </tr>
      </table>
    </div>

    <div class="section">
      <div class="section-header">④ Logging & Services</div>
      <table>
        <tr><th>ICAP REQ</th><th>ICAP RESP</th><th>HTTP Log</th><th>HTTPS Log</th>
            <th>Access Log Backup</th><th>Event Log Backup</th><th>Core Image</th></tr>
        <tr>
          <td>${icapReq}</td><td>${icapResp}</td><td>${httpLog}MB</td>
          <td>${httpsLog}MB</td><td>${Logbackup}</td><td>${syslogStatus}</td><td>${coreImage}</td>
        </tr>
      </table>
    </div>
    `;
  };
  reader.readAsText(file);
});
</script>

</body>
</html>
